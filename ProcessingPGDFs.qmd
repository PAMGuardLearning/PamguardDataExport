---
title: "Processing PAMGuard Data Files"
---

## Introductions

Various modules in PAMGuard produce binary files. Custom libraries written in MATLAB, R and Python exist to help you further process these files. In this tutorial, we will process a folder of **Click Detector** binary files, count clicks per minute and create a concatenated string of porpoise detections.

::: callout-note
### Version

NOTE ABOUT VERSIONS
:::

::: callout-warning
This tutorial uses example path names from both Windows and macOS/Linux. Make sure you alter path names accordingly for all exercises
:::

INSTRUCTIONS ON INSTALLING THE SOFTWARE

### Exercise 1: Open a Click Detector Binary File

For the first exercise of this tutorial, you will open a click detector binary file from the folder Data/porpoise_data/Binary/20130710/. This contains 26 files: thirteen data files (.pgdf) and thirteen index files (.pgdx). You will concern yourself solely with the thirteen data files (.pgdf). Select one of these files which you will open and process; then follow the instructions for your preferred programming language below.

::::: panel-tabset
## MATLAB

Below, we use `loadPamguardBinaryFile()` to load the click file into a data array `clicks` and metadata object `fileInfo`. The `clicks` variable is an array of data elements (clicks) in the binary file.

::: callout-note
## Accessing array elements in MATLAB

To access elements from an array in MATLAB you must use curved brackets starting at index one `(1)`, unlike most languages which use square backets from index zero `[0]`.
:::

``` matlab
import pgmatlab.*;

[clicks, fileInfo] = pgmatlab.loadPamguardBinaryFile("\enter\your\path\PamguardDevelopment\Binary\20120629\Click_Detector_Click_Detector_Clicks_20120629_094025.pgdf")

% get and print the first click
firstClick = clicks(1)
disp(firstClick)

% get and print startSample of the first click
firstClickStartSample = clicks(1).startSample
disp(firstClickStartSample)
```

To check that the file you have loaded is correctly a click detector you can access the file

## R

In R, we use `loadPamguardBinaryFile()` to load all contents of the processed data file into a single `clickFile` object. The `clickFile$data` attribute produces an array of data elements (clicks) in the binary file.

``` r
library(PamBinaries)
clickFile <- loadPamguardBinaryFile("\enter\your\path\PamguardDevelopment\Binary\20120629\Click_Detector_Click_Detector_Clicks_20120629_094025.pgdf")
clicks = clickFile$data

# get the first click
firstClick <- clicks[[0]]
print(firstClick)

# get startSample of the first click
firstClickStartSample <- clicks[[0]]$startSample
print(firstClickStartSample)
```

## Python

In Python we use `load_pamguard_binary_file()` to load all contents of the processed data file into a single `click_file` object. The `click_file.data` attribute produces an array of all data elements (clicks) in the binary file.

::: callout-note
## Python notation

In Python we use `snake_case` rather than `camelCase` (as used in MATLAB and R) to write out phrases such as variable and method names.
:::

``` python
from pypamguard import load_pamguard_binary_file

click_file = load_pamguard_binary_file("\enter\your\path\PamguardDevelopment\Binary\20120629\Click_Detector_Click_Detector_Clicks_20120629_094025.pgdf")
clicks = click__file.data

// get the first click
first_click = clicks[0]
print(first_click)

// get startSample of the first click
first_click_start_sample = clicks[0].start_sample
print(first_click_start_sample)
```
:::::

## Exercise 2: Plotting Waveform Data

Now that we have loaded in the data files into a more workable data structure, we will plot the the waveform data of the first click. You can build off of the code from exercise 1.

::: callout-note
Depending on how you set-up PAMGuard, the exact plots shown in this tutorial may not match those that you produce yourself. So long as you understand what the code is doing, this is not a problem.
:::

:::::: panel-tabset
## MATLAB

MATLAB has an in-built method `plot()` that simplifies plotting the waveform data.

``` matlab
%Get the 28th click - note that MATLAB counts from one
waveFormData=clicks(28).wave;
plot(waveFormData)
xlabel('Samples')
ylabel('Linear amplitude')
set(gca, 'FontSize', 14)
```

::: callout-note
Note that there may be more than one waveform in single click detection. This is because channels within the click detector can be grouped together. e.g. for a typical towed array survey where the two hydrophone elements within the towed array are close together, those two channels will be grouped- hence a single click detection would have two sets of waveform information, one for channel 0 and one for channel 1.
:::

![Waveform MATLAB](public/waveform-matlab.png)

## R

R has an in-built method `plot()` that simplifies plotting the waveform data. We need to create the x-axis manually by creating an array of integers `x` from 1 to the length of the waveform data. The use of the index `[,1]` cuts down a potential multi-channel waveform into a single-channel waveform of the lowest channel number.

``` r
#Get the 28th click - note that R counts from one
wave = clicks[28]$wave[,1]
x <-1:length(aclick$wave[,1])
plot(x, aclick$wave[,1], type = "l", lty = 1, col="red")
```

![Waveform R](public/waveform-r.png)

## Python

In Python the `matplotlib` library is required to plot data. The code below will plot all the waveform data from the first channel.

::: callout-important
Import matplotlib using `pip install matplotlib` in the command line / terminal. If you do not have matplotlib installed the following code will not work for you.
:::

``` python
import matplotlib.pyplot as plt
# code from previous exercise goes here
#Get the 28th click - note that Python counts from zero so the index is 27
plt.plot(clicks[27].wave[0])
plt.savefig('plot.png')
```

The code above will have saved the plot in a PNG file `plot.png` within your current working directory.

![Waveform Python](public/waveform-python.png)

::: callout-tip
# Plotting multiple channels

The code above plots the first channel from the waveform data of the click. A click may have one or more channels (`clicks[0].wave` is a 2-dimensional array, as such). You can write a for-loop, as shown below, to plot all the separate channels together. In the event that the click only has one channel, both code snippets shown in this exercise achieve the exact same thing.

``` python
import matplotlib.pyplot as plt
# code from previous exercise goes here
for chan in clicks[28].wave:
    plt.plot(chan)
plt.savefig('plot.png')
```
:::
::::::

## Exercise 3: Load a Folder of Click Files and Count the Classified Clicks

So far, we have opened one of the thirteen click files. In reality we want to deal with any number of files in a folder. In this exercise, we will read all thirteen binary files at once and count the number of classified clicks.

::: callout-note
# Classified click definition

`clicks[0]` is considered a classified click when `clicks[0].type == 1`.
:::

### Method 1: loading files individually into memory (recommended)

:::::: panel-tabset
### MATLAB

First, create an array of the files within your desired folder. The folder that you should load is the same of that which contained the click file in exercise 1. When we use the `fullFile()` method we pass in a file name mask `*.pgdf` to filter the files to only those with a .pgdf extension.

``` matlab
folderName = '/path/to/Data/porpoise_data/Binary/';
binaryFiles = dir(fullFile(folderName, '*.pgdf'));
```

::: callout-note
The variable `binaryFiles` is an array of MATLAB structures, each of which contains information about a file in the folder. This allows us to open up the files one-at-a-time to prevent excessive memory usage.
:::

Now we must create a for loop to go through each of the files in `binaryFiles`, and load them in using `loadPamguardBinaryFile()` (as in exercises 1 and 2).

``` matlab
for i = 1:length(binaryFiles)
    filePath = fullFile(folderName, binaryFiles(i).name);
    clicks = loadPamguardBinaryFile(filePath);
end
```

This code achieves very little. Each time we load one of the files, it is almost immediately dumped from memory as the loop enters its next iteration - no useful information is produced.

Now we will use a nested loop to count the number of porpoise clicks there exist in all thirteen data files in the folder. We use a technique called nested looping here to increment a global counter. The outer loop (where `i` is incremented) goes through all the files, and the inner loop (where `j` is incremented) goes through all the clicks in each file to check whether they are classified or not.

``` matlab
count = 0;
for i = 1:length(binaryFiles)
    filePath = fullFile(folderName, binaryFiles(i).name);
    clicks = loadPamguardBinaryFile(filePath);
    for j = 1:length(clicks)
        if (clicks(j).type == 1)
            count = count + 1
        end
    end
end
```

### R

First, create an array of the files within your desired folder. The folder that you should load is the same of that which contained the click file in exercise 1. We use the in-built method `list.files()` with a pattern `\\.pgdf$` to mask the files.

``` r
folderName = '/path/to/Data/porpoise_data/Binary/';
fileNames <- list.files(folderName, pattern = "\\.pgdf$")
```

::: callout-note
The variable `fileNames` is an array of file names (as strings). This allows us to open up the files one-at-a-time to prevent excessive memory usage.
:::

Now we must create a for-loop to go through each of the files represented by file names in `fileNames`, and load them in using `loadPamguardBinaryFile()` (as in exercises 1 and 2).

``` r
for (fileName in fileNames) {
    # load each click file.
    clicks <- loadPamguardBinaryFile(file.path(folder, fileName));  
}
```

This code achieves very little. Each time we load one of the files, it is almost immediately dumped from memory as the loop enters its next iteration - no useful information is produced.

Now we will use a nested loop to count the number of porpoise clicks there exist in all thirteen data files in the folder. We use a technique called nested looping here to increment a global counter. The outer loop goes through all the files, and the inner loop goes through all the clicks in each file to check whether they are classified or not.

``` r
count = 0;
for (fileName in fileNames) {
    # load each click file.
    clicks <- loadPamguardBinaryFile(file.path(folder, fileName));
    # iterate through the click files to count the classified clicks.
    for (click in clicks$data) {
        if (click$type == 1) {
            count = count + 1;
        }
    }
}
```

### Python

First, create an array of the files within your desired folder. The folder that you should load is the same of that which contained the click file in exercise 1. We use the native Python library `pathlib` to list all files within a folder (using the `Path` class), and mark them using the mask `*.pgdf`.

``` python
import pathlib, pypamguard
folder_name = '../Data/porpoise_data/Binary/20130710'
file_names = pathlib.Path(folder_name).glob('*.pgdf')
```

::: callout-note
The variable `file_names` is an array of file names (as strings). This allows us to open up the files one-at-a-time to prevent excessive memory usage.
:::

Now we must create a for-loop to go through each of the files in `file_names`, and load them in using `load_pamguard_binary_file()` (as in exercises 1 and 2).

``` python
# code to create file_names variable goes here
for file_name in file_names:
    clicks = pypamguard.load_pamguard_binary_file(pathlib.Path(file_name))
```

This code achieves very little. Each time we load one of the files, it is almost immediately dumped from memory as the loop enters its next iteration - no useful information is produced.

Now we will use a nested loop to count the number of porpoise clicks there exist in all thirteen data files in the folder. We use a technique called nested looping here to increment a global counter. The outer loop goes through all the files, and the inner loop goes through all the clicks in each file to check whether they are classified or not.

``` python
# code to create file_names variable goes here
count = 0;
for file_name in file_names:
    clicks = pypamguard.load_pamguard_binary_file(pathlib.Path(file_name))
    for click in clicks.data:
        if click.type == 1:
            count += 1;
```
::::::

### Method 2: loading all data into memory at once (memory intensive)

Each library has a function you can use to load all the files in a folder into memory at once. This can offer simplicity with respect to the nested loops you wrote above as you would no longer be responsible for looping through the individual files in the folder you wish to read.

::: callout-warning
# Use at own risk

The method to load all files in the folder into memory at once places a heavy burden on your computer's memory. Only use this function if you are processing a small number of files, or are pre-filtering them significantly (we do not cover that in this tutorial).
:::

::: panel-tabset
## MATLAB

``` matlab
folderName = '/path/to/Data/porpoise_data/Binary/';
clicksAll = loadPamguardBinaryFolder(folderName, "Click_Detector_Click_Detector_Clicks_*.pgdf");
count = 0;
for i = 1:length(clicksAll)
    if (clicksAll(i).type == 1)
        count = count + 1;
    end
end
```

## R

``` r
folderName = '/path/to/Data/porpoise_data/Binary/';
clicksAll = loadPamguardBinaryFolder(folderName);
count = 0;
for (click in clicksAll$data) {
    if (click$type == 1) {
        count = count + 1;
    }
}
```

## Python

``` python
import pypamguard
folder_name = '../Data/porpoise_data/Binary/20130710'
clicks_all = pypamguard.load_pamguard_binary_folder(folder_name)
count = 0
for click in clicks_all.data:
    if click.type == 1:
        count += 1
```
:::

## Exercise 4: Loading Whistle Files

In this exercise we will open another type of file: the whistle file. This differs from click data as it is produced by the [PAMGuard Whistle and Moan Detector](). It will become quite obvious the similarities and differences between the click detector and whistle files.

::: callout-note
# Fun fact

PAMGuard has a large number of modules. Each module produces different kinds of data, each of which can be read into the R, MATLAB or Python libraries for reading PAMGuard data files. This tutorial, which concerns the Click Detector and Whistle and Moan Detector, only scratches the surface of what PAMGuard, and these data file readers are capable of.
:::

You will open the file stored at Data/whistle binary/Binary/20190403/WhistlesMoans_Whistle_and_Moan_Detector_Contours_20190403_133052.pgdf in your preferred programming language. Depending on the [working directory]() of your terminal or editor, you may need to adjust the relative path of the data file.

::: panel-tabset
## MATLAB

``` matlab
import pgmatlab.*;
[data, fileInfo] = pgmatlab.loadPamguardBinaryFile("./Data/whistle binary/Binary/20190403/WhistlesMoans_Whistle_and_Moan_Detector_Contours_20190403_133052.pgdf");
```

The `data` struct produced by the code above will contain at least the following attributes. Please familiarise yourself with them, before continuing on to the next section.

+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| MATLAB        | Meaning                                                                                                                                                                                                |
+===============+========================================================================================================================================================================================================+
| `millis`      | The start time of the whistle in milliseconds.                                                                                                                                                         |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `startSample` | The first sample of the whistle often used for finer-scale time delay measurements.                                                                                                                    |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `uid`         | A unique identifier for the whistle.                                                                                                                                                                   |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `channelMap`  | The channel map for this whistle (one integer, made up of 32 bits, where each bit has a value 0 or 1 specifying the existence of that channel in the `contour`.                                        |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `nSlices`     | The number of slices the whistle's `contour` is created from.                                                                                                                                          |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `amplitude`   | The amplitude of the whistle.                                                                                                                                                                          |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `sliceData`   | An array of contour slices, with each slice `x` containing:                                                                                                                                            |
|               |                                                                                                                                                                                                        |
|               | -   `sliceData(x).sliceNumber`: book-keeping;                                                                                                                                                          |
|               |                                                                                                                                                                                                        |
|               | -   `sliceData(x).nPeaks`: number of peaks;                                                                                                                                                            |
|               |                                                                                                                                                                                                        |
|               | -   `sliceData(x).peakData`: peak data;                                                                                                                                                                |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `contour`     | An array of the same length as `sliceData` where each element `contour(x)` is the first frequency peak which defines the contour (`sliceData(x).peakData(2,1)`).                                       |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `contWidth`   | An array of the same length as `sliceData` where each element `contWidth(x)` is the width of the first frequency peak in that contour slice (`sliceData(x).peakData(3,1)-sliceData(x).peakData(1,1)`). |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

## R

``` r
library(PamBinaries)
binaryFile <- loadPamguardBinaryFile("./Data/whistle binary/Binary/20190403/WhistlesMoans_Whistle_and_Moan_Detector_Contours_20190403_133052.pgdf")
data = clickFile$data
```

The `data` variable produced by the code above will contain at least the following attributes. Please familiarise yourself with them, before continuing on to the next section.

+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| R             | Meaning                                                                                                                                                                                                                  |
+===============+==========================================================================================================================================================================================================================+
| `millis`      | The start time of the whistle in milliseconds.                                                                                                                                                                           |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `startSample` | The first sample of the whistle often used for finer-scale time delay measurements.                                                                                                                                      |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `uid`         | A unique identifier for the whistle.                                                                                                                                                                                     |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `channelMap`  | The channel map for this whistle (one integer, made up of 32 bits, where each bit has a value 0 or 1 specifying the existence of that channel in the `contour`.                                                          |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `nSlices`     | The number of slices the whistle's `contour` is created from.                                                                                                                                                            |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `amplitude`   | The amplitude of the whistle.                                                                                                                                                                                            |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `sliceData`   | TODO: CONFIRM - An array of contour slices, with each slice `x` containing:                                                                                                                                              |
|               |                                                                                                                                                                                                                          |
|               | -   `sliceData[x]$sliceNumber`: book-keeping;                                                                                                                                                                            |
|               |                                                                                                                                                                                                                          |
|               | -   `sliceData[x]$nPeaks`: number of peaks;                                                                                                                                                                              |
|               |                                                                                                                                                                                                                          |
|               | -   `sliceData[x]$peakData`: peak data;                                                                                                                                                                                  |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `contour`     | TODO: CONFIRM - An array of the same length as `sliceData` where each element `contour(x)` is the first frequency peak which defines the contour (`sliceData[x]$peakData[0][1]`).                                        |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `contWidth`   | TODO: CONFIRM - An array of the same length as `sliceData` where each element `contWidth(x)` is the width of the first frequency peak in that contour slice (`sliceData(x)$peakData[0][2]-sliceData(x)$peakData[0][0]`). |
+---------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

## Python

``` python
import pypamguard
binaryFile = pypamguard.load_pamguard_binary_file("./Data/whistle binary/Binary/20190403/WhistlesMoans_Whistle_and_Moan_Detector_Contours_20190403_133052.pgdf")
data = binaryFile.data
```

The `data` variable produced by the code above will contain at least the following attributes. Please familiarise yourself with them, before continuing on to the next section.

+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Python          | Meaning                                                                                                                                                         |
+=================+=================================================================================================================================================================+
| `millis`        | The start time of the whistle in milliseconds.                                                                                                                  |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `start_sample`  | The first sample of the whistle often used for finer-scale time delay measurements.                                                                             |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `uid`           | A unique identifier for the whistle.                                                                                                                            |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `channel_map`   | The channel map for this whistle (one integer, made up of 32 bits, where each bit has a value 0 or 1 specifying the existence of that channel in the `contour`. |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `n_slices`      | The number of slices the whistle's `contour` is created from.                                                                                                   |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `amplitude`     | The amplitude of the whistle.                                                                                                                                   |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `slice_numbers` | An array of numbers: each element `slice_numbers[x]` containing a book-keeping number for a slice.                                                              |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `n_peaks`       | A parallel array to `slice_numbers`, each element `n_peaks[x]` containing the number of peaks in that slice.                                                    |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `peak_data`     | A parallel array to `slice_numbers`, each element `peak_data[x]` containing a sub-array of peak frequency-related data for that slice.                          |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `contour`       | A parallel array to `slice_numbers`, each element `contour[x]` containing the peak frequency of that slice (`peak_data[x][1]`).                                 |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `cont_width`    | A parallel array to `slice_numbers`, each element `slice_numbers[x]` containing the frequency width of that slice (`peak_data[x][2] - peak_data[x][0]`).        |
+-----------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
:::

## Exercise 5: Plotting Whistle Contours

We will now plot all the whistle contours on a graph with each contour starting at `x = 0`. This is a neat way to visualise whistle detections and shows a snapshot of the whistle distribution with frequency.

::::: panel-tabset
#### MATLAB

To do this, we loop through each of the whistles in `data`, plotting the peak frequencies from the `contour` attribute of each struct.

::: callout-note
###### Calculating the true frequency of each contour

We use user-defined `sampleRate` and `fftLength` variables to calculate the true frequency of each peak frequency data point in the contour.
:::

::: callout-tip
###### Plotting more than one line on the same graph

The `hold on;` and `hold off;` statements provide a way to plot a lot of data on the same plot.
:::

``` matlab
%% Exercise 5
figure
% Code from the previous exercise goes here
sampleRate = 96000;
fftLength = 1024;
hold on;
for i = 1:min([length(data) 1000])
    contour = data(i).contour * sampleRate / fftLength;
    myplot(i) = plot(contour, 'g', 'LineWidth', 0.5);
    disp(['Plotting whislte ' num2str(i) ' of ' num2str(length(data))])
end
ylim([0,48000]);
hold off;
xlabel('Time (slices)')
ylabel('Frequency (Hz)')
set(gca, 'FontSize', 14)

```

Execution of this code should produce a graph that looks something like this.

![](./public/whistle-contour-plot-matlab.png)

#### R

To do this, we loop through each of the whistles in the `data` variable, plotting the peak frequencies from the `contour` attribute of each object.

```r
# Code from the previous exercise goes here
# Put some code here
```

Execution of this code should produce a graph that looks something like this.

#### Python

To do this, we loop through each of the whistles in the `data` 

```python
import matplotlib.pyplot as plt
# Code from the previous exercise goes here

sample_rate = 96000
fft_length = 1024


plt.figure(figsize=(8, 8))

num_contours = min(len(binaryFile.data), 1000)

for whistle in binaryFile.data[:num_contours]:
    contour = whistle.contour * (sample_rate / fft_length)
    plt.plot(contour, color='lawngreen', alpha=0.2)
plt.xlabel('Time (slices)')         # Set your desired x-axis label
plt.ylabel('Frequency (Hz)')        # Set your desired y-axis label

plt.xlim(0, 100)    # Set x-axis limits from 0 to 100 (change as needed)
plt.ylim(0, 50000)   # Set y-axis limits from 0 to 50000 Hz (change as needed)

plt.show()
```

Execution of this code should produce a graph that looks something like this.

![](./public/whistle-contour-plot-python.png)

:::::

## Exercise 6: Creating a Long Term Spectral Average

A long term spectral average (LTSA) can be very useful for getting a quick overview of long time periods of acoustic data. PAMGuard can produce an LTSA analysis, and output such data to a PAMGuard binary file.

::: callout-tip
Other tutorials on the PAMGuard website have step by step guides on how to use PAMGuard to generate long term spectral averages. 
:::

We will be working with LTSA data found in the Data/LTSA/ folder. There are multiple data files in this folder, because PAMGuard has purposely split-up data to ensure small manageable files. We will load the entire folder at once, allowing all the requested LTSA data to be plotted at once.

:::::: panel-tabset

### MATLAB

```matlab
import pgmatlab;


%load the data
ltsa = pgmatlab.loadPamguardBinaryFolder("/Users/jdjm/Dropbox/PAMGuard_dev/tutorials/MATLAB_R_Python_library/Data/LTSA/Binary2", "LTSA_*.pgdf", 1);
sr = 384000; %samplerate in Hz
n = 1;

ltsa_spectrum=[];
times=[];
% Run through the ltsa data and extract the data into a 2D array to plot as
% surface. Here we select every second LTSA data point as there are ~12,000
% measurements and that can be hard to plot as a surface on some computers
for i = 1 : 2 : (length(ltsa) - 1)
    if (~isempty(ltsa(i).data))
    ltsa_spectrum(:, n) = ltsa(i).data(:,1);
    times(n) = ltsa(i).date;
    n=n+1;
    end

end

% Create a surface with the correct frequency and times - plot in kHz as a
% lot easier to see. 
freqbins = linspace(0, sr/1000/2, length( ltsa_spectrum(:,1)));

%Create a grid of times and frequencies.
[X, Y] = meshgrid(...
    times,...
    freqbins);
    
figure
% plot the surface
surf(X, Y, 20*log10(ltsa_spectrum), 'LineStyle', 'none')
view(0,90)
%set the colour limits to make the plot have correct contrast - this can be
%a bot of trial and error
clim([-55, -25]);
set(gca, 'FontSize', 14)
%show times instead of date numbers on the x axis
datetick 'x'
%add labels to axis
xlabel('Time')
ylabel('Frequency (kHz)')
%make sure limits in time are correct to remove blank space
xlim([min(times), max(times)])

```

Execution of this code should produce an LTSA plot that looks something like this.

![](./public/LTSA_matlab.png)

### R

Not too sure

### Python

```python
import numpy as np

ltsa, background, report = pypamguard.load_pamguard_binary_folder("/Users/jdjm/Dropbox/PAMGuard_dev/tutorials/MATLAB_R_Python_library/Data/LTSA/Binary2/",r"**/*.pgdf")

print(type(ltsa))

# Initialize variables
ltsa_spectrum_list = [] # Use a list to dynamically collect columns
n=1;
sr = 384000
times = []

# Extract data into a 2D array and times
# We only select every second LTSA data line to reduce the size of the image.
for i in range(0, len(ltsa), 2):
    # Check if data are empty and the channel is the same
    if hasattr(ltsa[i], 'data') and ltsa[i].data is not None:
        # Extract the first column of the spectrum data
        ltsa_spectrum_list.append(ltsa[i].data[:])
        
        # Extract the date/time
        times.append(ltsa[i].date)
        

# Convert the list of arrays (columns) to a single numpy array
if ltsa_spectrum_list:
    # Stack the columns and transpose it to match the plotting requirement (Frequency x Time)
    ltsa_spectrum = np.stack(ltsa_spectrum_list, axis=1) 
else:
    print("No valid LTSA data found for the specified channel map.")
    ltsa_spectrum = np.array([])

# Ensure we have data before plotting
if ltsa_spectrum.size > 0:
    
    #need to flip the arrays as they are back to front time wise. 
    Z_db = 20 * np.log10(ltsa_spectrum[:, ::-1])
    times = times[::-1]
        
    # Frequency: from 0 to calculated maximum
    f_min = 0
    f_max = sr/1000/2

    # Time: Convert datetime objects to Matplotlib's internal date numbers
    # imshow requires numerical values for extent
    t_num = mdates.date2num(times)
    t_min = t_num.min()
    t_max = t_num.max()
    
    # Determine the time step size (in Matplotlib date numbers)
    # This helps accurately place the final pixel of the image.
    if len(t_num) > 1:
        dt = np.mean(np.diff(t_num)) 
    else:
        # Assume a small duration if only one point exists (e.g., 1 hour)
        dt = 1/24 
    
    # The extent defines the boundaries [xmin, xmax, ymin, ymax]
    # We slightly extend the max time by the duration (dt) for a clean plot boundary
    extent = [t_min, t_max + dt, f_min, f_max]
    
    # 4. Plot using imshow
    fig, ax = plt.subplots(figsize=(15, 6))
    
    # Use imshow to plot the 2D array (Z_db)
    # We need to transpose the data so Time is on the X-axis and Freq on the Y-axis.
    # origin='lower' ensures frequency starts at the bottom.
    im = ax.imshow(
        Z_db, 
        aspect='auto', 
        interpolation='none',
        origin='lower',
        extent=extent, # Numerical limits for the axes
        vmin=-55, # clim equivalent
        vmax=-25  # clim equivalent
    )
    
    # Set color bar
    fig.colorbar(im, ax=ax, label='Power (dB)')
    
    # 5. Format the Time Axis
    # Convert numerical time axis back to formatted datetimes
    ax.xaxis_date() 
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S')) 
    ax.xaxis.set_major_locator(mdates.AutoDateLocator())
    
    # Set font size and labels
    ax.tick_params(axis='both', which='major', labelsize=14)
    ax.set_title('LTSA Spectrogram')
    ax.set_xlabel('Time')
    ax.set_ylabel('Frequency (kHz)')
    
    fig.autofmt_xdate()
    plt.tight_layout()
    plt.show()
```


Execution of this code should produce an LTSA plot that looks something like this.

![](./public/LTSA_python.png)

::::::

## You're Done

You should now have the basic skills to load binary files and folders in MATLAB, R and/or Python. We have only explored a few examples here but you should now have a good understanding of the capabilities of these libraries and understand how they can be useful for analysis of results, creating plots for papers and further analysis outwith PAMGuard. 
